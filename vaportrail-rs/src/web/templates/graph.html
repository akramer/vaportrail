<h1>Graph - {{target_name}}</h1>

<div style="margin-bottom: 20px; display: flex; align-items: center; gap: 10px;">
    <a href="/">‚Üê Back to Dashboard</a>

    <span style="margin-left: 20px;">Start:</span>
    <input type="datetime-local" id="start-time">

    <span>End:</span>
    <input type="datetime-local" id="end-time">

    <button onclick="updateTimeRange()">Update</button>
    <button onclick="setRange('1h')">1h</button>
    <button onclick="setRange('24h')">24h</button>
    <button onclick="setRange('7d')">7d</button>
    <button onclick="setRange('30d')">30d</button>
</div>

<div class="chart-container" style="height: 500px;">
    <canvas id="main-chart"></canvas>
</div>

<script>
    const targetId = {{target_id}};

    function initTimeInputs() {
        const end = new Date();
        const start = new Date(end.getTime() - 60 * 60 * 1000);
        setTimeInputs(start, end);
    }

    function setTimeInputs(start, end) {
        const toLocalISO = (d) => {
            const offset = d.getTimezoneOffset() * 60000;
            return new Date(d.getTime() - offset).toISOString().slice(0, 16);
        };
        document.getElementById('start-time').value = toLocalISO(start);
        document.getElementById('end-time').value = toLocalISO(end);
    }

    function setRange(range) {
        const end = new Date();
        let start;
        switch (range) {
            case '1h': start = new Date(end.getTime() - 60 * 60 * 1000); break;
            case '24h': start = new Date(end.getTime() - 24 * 60 * 60 * 1000); break;
            case '7d': start = new Date(end.getTime() - 7 * 24 * 60 * 60 * 1000); break;
            case '30d': start = new Date(end.getTime() - 30 * 24 * 60 * 60 * 1000); break;
            default: start = new Date(end.getTime() - 60 * 60 * 1000);
        }
        setTimeInputs(start, end);
        updateTimeRange();
    }

    function getTimeRange() {
        const startVal = document.getElementById('start-time').value;
        const endVal = document.getElementById('end-time').value;
        if (startVal && endVal) {
            return { start: new Date(startVal), end: new Date(endVal) };
        }
        return null;
    }

    async function updateTimeRange() {
        const range = getTimeRange();
        if (!range) return;

        const url = '/api/results?target_id=' + targetId + '&start=' + range.start.toISOString() + '&end=' + range.end.toISOString() + '&include_raw=true';
        const res = await fetch(url);
        const response = await res.json();
        const data = response.results || [];
        const rawData = response.raw || [];

        const ctx = document.getElementById('main-chart');
        const existingChart = Chart.getChart('main-chart');
        if (existingChart) existingChart.destroy();

        const labels = data.map(d => d.time);
        const p50Data = data.map(d => d.p50 / 1000000);
        const p99Data = data.map(d => d.p99 / 1000000);
        const p1Data = data.map(d => d.p1 / 1000000);

        const datasets = [
            { label: 'P99 (ms)', data: p99Data, borderColor: '#FF0000', backgroundColor: '#FF0000', fill: false, pointRadius: 0 },
            { label: 'P50 (ms)', data: p50Data, borderColor: '#00FF00', backgroundColor: '#00FF00', fill: false, pointRadius: 0 },
            { label: 'P1 (ms)', data: p1Data, borderColor: '#0000FF', backgroundColor: '#0000FF', fill: false, pointRadius: 0 }
        ];

        // Add raw data as scatter points if available
        if (rawData.length > 0) {
            const rawPoints = rawData
                .filter(r => r.latency > 0)
                .map(r => ({ x: r.time, y: r.latency / 1000000 }));
            datasets.push({
                label: 'Raw',
                data: rawPoints,
                type: 'scatter',
                borderColor: 'rgba(0,0,0,0.3)',
                backgroundColor: 'rgba(0,0,0,0.3)',
                pointRadius: 2
            });
        }

        new Chart(ctx.getContext('2d'), {
            type: 'line',
            data: { labels: labels, datasets: datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: { mode: 'index', intersect: false },
                scales: {
                    x: { type: 'timeseries', time: { unit: 'minute' } },
                    y: { type: 'linear', title: { display: true, text: 'Latency (ms)' }, beginAtZero: true }
                },
                plugins: {
                    zoom: {
                        zoom: {
                            drag: { enabled: true },
                            mode: 'x',
                            onZoomComplete: function ({ chart }) {
                                const { min, max } = chart.scales.x;
                                setTimeInputs(new Date(min), new Date(max));
                                updateTimeRange();
                            }
                        }
                    }
                }
            }
        });
    }

    window.addEventListener('load', () => {
        initTimeInputs();
        updateTimeRange();
    });
</script>