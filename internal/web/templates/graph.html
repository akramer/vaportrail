{{template "header" .}}

<h1>{{.Name}}</h1>
<p>
    <strong>Address:</strong> {{.Address}} |
    <strong>Type:</strong> {{.ProbeType}} |
    <strong>Interval:</strong> {{.ProbeInterval}}s
</p>

<div class="controls">
    <span>Presets:</span>
    <button onclick="setRange('1h')">Last 1h</button>
    <button onclick="setRange('24h')">Last 24h</button>
    <button onclick="setRange('7d')">Last 7d</button>
    <button onclick="setRange('30d')">Last 30d</button>

    <span style="margin-left: 20px; margin-right: 5px;">Move:</span>
    <button onclick="moveTime(-60)">-1h</button>
    <button onclick="moveTime(-5)">-5m</button>
    <button onclick="moveTime(5)">+5m</button>
    <button onclick="moveTime(60)">+1h</button>

    <span style="margin-left: 20px;">Range:</span>
    <input type="datetime-local" id="start-time">
    <span>to</span>
    <input type="datetime-local" id="end-time">
    <button onclick="updateFromInputs()">Go</button>

    <span style="margin-left: 20px;">Graph Mode: </span>
    <select id="graph-mode" onchange="changeGraphMode(this.value)">
        <option value="heatmap">Heatmap</option>
        <option value="line">Line Chart</option>
    </select>
    <span style="margin-left: 20px;">
        <input type="checkbox" id="show-raw" onchange="loadChart()">
        <label for="show-raw">Show Raw Timings</label>
    </span>
</div>

<style>
    #tooltip-overlay {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: #fff;
        padding: 10px;
        border-radius: 5px;
        pointer-events: none;
        font-family: monospace;
        font-size: 12px;
        z-index: 100;
        display: none;
        min-width: 150px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    }
</style>

<div class="chart-container" style="position: relative;">
    <div id="tooltip-overlay"></div>
    <canvas id="chart"></canvas>
</div>

<script>
    const targetID = {{.ID }};
    let currentGraphMode = 'heatmap';
    let chartInstance = null;

    function toLocalISO(d) {
        const offset = d.getTimezoneOffset() * 60000;
        return new Date(d.getTime() - offset).toISOString().slice(0, 16);
    }

    function setInputs(start, end) {
        document.getElementById('start-time').value = toLocalISO(start);
        document.getElementById('end-time').value = toLocalISO(end);
    }

    function getInputs() {
        const s = document.getElementById('start-time').value;
        const e = document.getElementById('end-time').value;
        if (s && e) {
            return { start: new Date(s), end: new Date(e) };
        }
        return null;
    }

    function setRange(range) {
        const end = new Date();
        let start = new Date();
        switch (range) {
            case '1h': start.setTime(end.getTime() - 1 * 60 * 60 * 1000); break;
            case '24h': start.setTime(end.getTime() - 24 * 60 * 60 * 1000); break;
            case '7d': start.setTime(end.getTime() - 7 * 24 * 60 * 60 * 1000); break;
            case '30d': start.setTime(end.getTime() - 30 * 24 * 60 * 60 * 1000); break;
        }
        setInputs(start, end);
        loadChart();
    }

    function moveTime(minutes) {
        const range = getInputs();
        if (!range) return;
        const diff = minutes * 60 * 1000;
        const newStart = new Date(range.start.getTime() + diff);
        const newEnd = new Date(range.end.getTime() + diff);
        setInputs(newStart, newEnd);
        loadChart();
    }

    function updateFromInputs() {
        loadChart();
    }

    function changeGraphMode(mode) {
        currentGraphMode = mode;
        loadChart();
    }

    // Initialize with Last 1h
    window.addEventListener('load', () => {
        setRange('1h');
    });

    async function loadChart() {
        const range = getInputs();
        if (!range) return;

        // 1. Fetch Aggregated Data (Always)
        const aggUrl = '/api/results/' + targetID + '?start=' + range.start.toISOString() + '&end=' + range.end.toISOString();
        const aggRes = await fetch(aggUrl);
        const aggData = await aggRes.json();
        if (!aggData) return;

        let rawData = [];
        const showRaw = document.getElementById('show-raw').checked;

        // 2. Fetch Raw Data (If checked)
        if (showRaw) {
            const rawUrl = aggUrl + '&raw=true';
            const rawRes = await fetch(rawUrl);
            if (!rawRes.ok) {
                if (rawRes.status === 400) {
                    const msg = await rawRes.text();
                    alert(msg);
                    document.getElementById('show-raw').checked = false;
                    // Continue rendering aggregated only
                } else {
                    console.error("Failed to load raw data", rawRes);
                }
            } else {
                rawData = await rawRes.json();
            }
        }

        const ctx = document.getElementById('chart');
        if (chartInstance) {
            chartInstance.destroy();
        }

        // Use aggregated data for labels and main datasets
        const data = aggData;
        // Map bar data to objects with x and y
        const barData = data.map(d => {
            const timeMs = new Date(d.Time).getTime();
            const windowMs = (d.WindowSeconds || 60) * 1000; // Default to 60s if missing
            return {
                x: timeMs + windowMs / 2, // Shift right by half window to align start
                y: [
                    (d.P1 !== undefined && d.P1 !== 0 ? d.P1 : (d.P0 !== undefined && d.P0 !== 0 ? d.P0 : d.MinNS)) / 1000000,
                    (d.P99 !== undefined && d.P99 !== 0 ? d.P99 : (d.P100 !== undefined && d.P100 !== 0 ? d.P100 : d.MaxNS)) / 1000000
                ],
                originalTime: d.Time // Keep original for tooltip
            };
        });

        const chartCtx = ctx.getContext('2d');

        if (currentGraphMode === 'heatmap') {
            const dataset = {
                label: 'Latency Range',
                data: barData,
                backgroundColor: function (context) {
                    const chart = context.chart;
                    const { ctx, chartArea, scales } = chart;
                    if (!chartArea) return null;

                    const index = context.dataIndex;
                    const d = data[index];
                    if (!d || d.ProbeCount === 0) return 'rgba(0,0,0,0)';

                    if (d.Percentiles && d.Percentiles.length === 21) {
                        const pValues = d.Percentiles.map(v => v / 1000000);
                        const p1Val = (d.P1 !== undefined && d.P1 !== 0 ? d.P1 : pValues[0]) / 1000000;
                        const topY = scales.y.getPixelForValue((d.P99 || pValues[20]) / 1000000);
                        const bottomY = scales.y.getPixelForValue((d.P1 || pValues[0]) / 1000000);

                        if (Math.abs(topY - bottomY) < 0.1) return 'rgba(0,0,0,1)';

                        const gradient = ctx.createLinearGradient(0, topY, 0, bottomY);

                        // Collect stops with their brightness
                        let stops = [];
                        for (let i = 0; i <= 20; i++) {
                            const val = pValues[i];
                            const y = scales.y.getPixelForValue(val);
                            let stop = (y - topY) / (bottomY - topY);
                            // Normalize stop: 0 at top (P99), 1 at bottom (P1)
                            stop = Math.max(0, Math.min(1, stop));

                            const dist = Math.abs(i - 10);
                            const brightness = Math.floor((dist / 10) * 200);
                            stops.push({ stop, brightness });
                        }

                        // Sort stops by offset ascending
                        stops.sort((a, b) => a.stop - b.stop);

                        // Deduplicate stops at same position, keeping the darkest (min brightness)
                        let uniqueStops = [];
                        if (stops.length > 0) {
                            let current = stops[0];
                            for (let i = 1; i < stops.length; i++) {
                                const next = stops[i];
                                if (Math.abs(next.stop - current.stop) < 1e-5) {
                                    // Merge: keep darker
                                    if (next.brightness < current.brightness) {
                                        current.brightness = next.brightness;
                                    }
                                } else {
                                    uniqueStops.push(current);
                                    current = next;
                                }
                            }
                            uniqueStops.push(current);
                        }

                        uniqueStops.forEach(s => {
                            gradient.addColorStop(s.stop, `rgba(${s.brightness}, ${s.brightness}, ${s.brightness}, 1)`);
                        });
                        return gradient;
                    }
                    return 'black';
                },
                borderWidth: 0,
                barPercentage: 1.0,
                categoryPercentage: 1.0,
                xAxisID: 'x',
                grouped: false, // Prevent reserving space for other datasets
                order: 10 // Draw behind scatter
            };

            const backgroundPlugin = {
                id: 'customCanvasBackgroundColor',
                beforeDraw: (chart) => {
                    const { ctx, chartArea, scales } = chart;
                    ctx.save();
                    // For background, we need to map x to pixels
                    data.forEach((d, i) => {
                        const total = d.ProbeCount + d.TimeoutCount;
                        if (total === 0) return;
                        const timeoutPct = d.TimeoutCount / total;

                        const meta = chart.getDatasetMeta(0);
                        const bar = meta.data[i];
                        if (bar) {
                            const width = bar.width;
                            const x = bar.x - width / 2;
                            const gb = Math.floor(255 * (1 - timeoutPct));
                            ctx.fillStyle = `rgb(255, ${gb}, ${gb})`;
                            ctx.fillRect(x, chartArea.top, width, chartArea.bottom - chartArea.top);
                        }
                    });
                    ctx.restore();
                }
            };

            const hoverHighlightPlugin = {
                id: 'hoverHighlight',
                afterDatasetsDraw: (chart) => {
                    const activeElements = chart.getActiveElements();
                    if (activeElements.length > 0) {
                        const { ctx, chartArea } = chart;
                        const activePoint = activeElements[0];
                        const x = activePoint.element.x;
                        const width = activePoint.element.width;

                        ctx.save();
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.2)'; // Green tint
                        ctx.fillRect(x - width / 2, chartArea.top, width, chartArea.bottom - chartArea.top);
                        ctx.restore();
                    }
                }
            };

            let datasets = [dataset];
            if (rawData.length > 0) {
                const scatterData = rawData.map(d => ({ x: d.Time, y: d.MinNS / 1000000 }));
                datasets.push({
                    label: 'Raw Latency (ms)',
                    data: scatterData,
                    type: 'scatter',
                    backgroundColor: '#00ffff',
                    borderColor: '#00ffff',
                    borderWidth: 2,
                    pointRadius: 2,
                    xAxisID: 'xRaw',
                    grouped: false, // Overlay, don't stack/group
                    order: 1 // Draw on top (lower is on top)
                });
            }

            chartInstance = new Chart(chartCtx, {
                type: 'bar',
                data: { datasets: datasets }, // No global labels
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    scales: {
                        x: {
                            type: 'time', // Use time axis
                            time: { unit: 'minute', displayFormats: { minute: 'HH:mm', hour: 'MM-dd HH:mm' } },
                            grid: { display: false },
                            min: range.start.toISOString(),
                            max: range.end.toISOString(),
                            offset: false, // Ensure no extra padding
                            ticks: {
                                // source: 'data' // Removing this to prevent ticks from using the shifted bar centers (e.g. 2:30 offsets)
                            }
                        },
                        xRaw: {
                            type: 'time',
                            display: false,
                            min: range.start.toISOString(),
                            max: range.end.toISOString(),
                            offset: false
                        },
                        y: { type: 'linear', display: true, title: { display: true, text: 'Latency (ms)' } }
                    },
                    plugins: {
                        zoom: {
                            zoom: {
                                drag: { enabled: true },
                                mode: 'x',
                                onZoomComplete: function ({ chart }) {
                                    const { min, max } = chart.scales.x;
                                    setInputs(new Date(min), new Date(max));
                                    loadChart();
                                }
                            }
                        },
                        tooltip: {
                            enabled: false, // Disable default canvas tooltip
                            external: function (context) {
                                // Tooltip Element
                                let tooltipEl = document.getElementById('tooltip-overlay');

                                // Hide if no tooltip
                                const tooltipModel = context.tooltip;
                                if (tooltipModel.opacity === 0) {
                                    tooltipEl.style.display = 'none';
                                    return;
                                }

                                // Smart Relative Positioning (5% offset, prefer left)
                                const offset = context.chart.width * 0.05;
                                const tooltipWidth = tooltipEl.offsetWidth;
                                const chartLeft = context.chart.chartArea.left;
                                const caretX = tooltipModel.caretX;

                                let targetLeft = caretX - offset - tooltipWidth;

                                if (targetLeft < chartLeft) {
                                    // If runs off left side, flip to right
                                    tooltipEl.style.left = (caretX + offset) + 'px';
                                    tooltipEl.style.right = 'auto';
                                } else {
                                    // Otherwise keep on left
                                    tooltipEl.style.left = targetLeft + 'px';
                                    tooltipEl.style.right = 'auto';
                                }

                                // Set Text
                                if (tooltipModel.body) {
                                    const item = tooltipModel.dataPoints[0];
                                    const d = context.chart.data.datasets[item.datasetIndex].data[item.dataIndex]; // This is the barData object
                                    const originalData = data[item.dataIndex]; // This is the API result object

                                    // Safely access originalData
                                    if (!originalData) return;

                                    let content = '';
                                    // Title
                                    if (d.originalTime) {
                                        content += `<div style="font-weight:bold; margin-bottom:5px;">${new Date(d.originalTime).toLocaleString()}</div>`;
                                    }

                                    // Body
                                    if (originalData.Percentiles && originalData.Percentiles.length === 21) {
                                        for (let k = 10; k >= 0; k--) {
                                            const p = k * 10;
                                            const idx = k * 2;
                                            const val = originalData.Percentiles[idx] / 1e6;
                                            content += `<div>P${p}: ${val.toFixed(2)} ms</div>`;
                                        }
                                    } else {
                                        content += `<div>Max: ${(originalData.P100 / 1e6).toFixed(2)} ms</div>`;
                                        content += `<div>Median: ${(originalData.P50 / 1e6).toFixed(2)} ms</div>`;
                                        content += `<div>Min: ${(originalData.P0 / 1e6).toFixed(2)} ms</div>`;
                                    }
                                    content += `<hr style="border: 0; border-top: 1px solid #555; margin: 5px 0;">`;
                                    content += `<div>Success: ${originalData.ProbeCount}</div>`;
                                    content += `<div>Timeout: ${originalData.TimeoutCount}</div>`;

                                    tooltipEl.innerHTML = content;
                                }

                                // Display
                                tooltipEl.style.display = 'block';
                            }
                        }
                    },
                },
                plugins: [backgroundPlugin, hoverHighlightPlugin]
            });

        } else {
            // Line chart mode
            // Need to map data to x/y for line chart as well since we removed global labels and switched to time axis
            const p0Data = data.map(d => ({ x: d.Time, y: (d.P0 || d.MinNS) / 1000000 }));
            const p50Data = data.map(d => ({ x: d.Time, y: (d.P50) / 1000000 }));
            const p100Data = data.map(d => ({ x: d.Time, y: (d.P100 || d.MaxNS) / 1000000 }));
            const timeoutPercentageData = data.map(d => {
                const total = d.ProbeCount + d.TimeoutCount;
                return { x: d.Time, y: total > 0 ? (d.TimeoutCount / total) * 100 : 0 };
            });

            let datasets = [
                {
                    label: 'Timeout %',
                    data: timeoutPercentageData,
                    type: 'bar',
                    backgroundColor: 'rgba(255, 99, 132, 0.5)',
                    borderColor: 'rgba(255, 99, 132, 1)',
                    borderWidth: 1,
                    yAxisID: 'y1',
                    barPercentage: 0.5
                },
                { label: 'Max (P100)', data: p100Data, borderColor: '#FF0000', backgroundColor: '#FF0000', fill: false, tension: 0.1, borderWidth: 1, yAxisID: 'y' },
                { label: 'Median (P50)', data: p50Data, borderColor: '#00FF00', backgroundColor: '#00FF00', fill: false, tension: 0.1, borderWidth: 2, yAxisID: 'y' },
                { label: 'Min (P0)', data: p0Data, borderColor: '#4B0082', backgroundColor: '#4B0082', fill: false, tension: 0.1, borderWidth: 1, yAxisID: 'y' }
            ];

            if (rawData.length > 0) {
                const scatterData = rawData.map(d => ({ x: d.Time, y: d.MinNS / 1000000 }));
                datasets.push({
                    label: 'Raw Latency (ms)',
                    data: scatterData,
                    type: 'scatter',
                    backgroundColor: 'black',
                    borderColor: 'black',
                    borderWidth: 2,
                    pointRadius: 2,
                    yAxisID: 'y'
                });
            }

            chartInstance = new Chart(chartCtx, {
                type: 'line',
                data: {
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    scales: {
                        x: { type: 'time', time: { unit: 'minute', displayFormats: { minute: 'HH:mm', hour: 'MM-dd HH:mm' } }, grid: { display: false } },
                        y: { type: 'linear', display: true, position: 'left', beginAtZero: true },
                        y1: { type: 'linear', display: true, position: 'right', beginAtZero: true, min: 0, max: 100, grid: { drawOnChartArea: false } }
                    },
                    plugins: {
                        zoom: {
                            zoom: {
                                drag: { enabled: true },
                                mode: 'x',
                                onZoomComplete: function ({ chart }) {
                                    const { min, max } = chart.scales.x;
                                    setInputs(new Date(min), new Date(max));
                                    loadChart();
                                }
                            }
                        }
                    }
                }
            });
        }
    }
</script>
</script>
{{template "footer" .}}