<!DOCTYPE html>
<html>

<head>
    <title>{{.Name}} - VaporTrail</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
        }

        .controls {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .chart-container {
            position: relative;
            height: 500px;
            width: 100%;
        }

        button.active {
            background-color: #007bff;
            color: white;
            border-color: #0056b3;
        }
    </style>
</head>

<body>
    <h1><a href="/" style="text-decoration: none; color: inherit;">VaporTrail</a> / {{.Name}}</h1>
    <p>
        <strong>Address:</strong> {{.Address}} |
        <strong>Type:</strong> {{.ProbeType}} |
        <strong>Interval:</strong> {{.ProbeInterval}}s
    </p>

    <div class="controls">
        <span>Presets:</span>
        <button onclick="setRange('1h')">Last 1h</button>
        <button onclick="setRange('24h')">Last 24h</button>
        <button onclick="setRange('7d')">Last 7d</button>
        <button onclick="setRange('30d')">Last 30d</button>

        <span style="margin-left: 20px; margin-right: 5px;">Move:</span>
        <button onclick="moveTime(-60)">-1h</button>
        <button onclick="moveTime(-5)">-5m</button>
        <button onclick="moveTime(5)">+5m</button>
        <button onclick="moveTime(60)">+1h</button>

        <span style="margin-left: 20px;">Range:</span>
        <input type="datetime-local" id="start-time">
        <span>to</span>
        <input type="datetime-local" id="end-time">
        <button onclick="updateFromInputs()">Go</button>

        <span style="margin-left: 20px;">Graph Mode: </span>
        <select id="graph-mode" onchange="changeGraphMode(this.value)">
            <option value="heatmap">Heatmap</option>
            <option value="line">Line Chart</option>
        </select>
    </div>

    <div class="chart-container">
        <canvas id="chart"></canvas>
    </div>

    <script>
        const targetID = {{.ID }};
        let currentGraphMode = 'heatmap';
        let chartInstance = null;

        function toLocalISO(d) {
            const offset = d.getTimezoneOffset() * 60000;
            return new Date(d.getTime() - offset).toISOString().slice(0, 16);
        }

        function setInputs(start, end) {
            document.getElementById('start-time').value = toLocalISO(start);
            document.getElementById('end-time').value = toLocalISO(end);
        }

        function getInputs() {
            const s = document.getElementById('start-time').value;
            const e = document.getElementById('end-time').value;
            if (s && e) {
                return { start: new Date(s), end: new Date(e) };
            }
            return null;
        }

        function setRange(range) {
            const end = new Date();
            let start = new Date();
            switch (range) {
                case '1h': start.setTime(end.getTime() - 1 * 60 * 60 * 1000); break;
                case '24h': start.setTime(end.getTime() - 24 * 60 * 60 * 1000); break;
                case '7d': start.setTime(end.getTime() - 7 * 24 * 60 * 60 * 1000); break;
                case '30d': start.setTime(end.getTime() - 30 * 24 * 60 * 60 * 1000); break;
            }
            setInputs(start, end);
            loadChart();
        }

        function moveTime(minutes) {
            const range = getInputs();
            if (!range) return;
            const diff = minutes * 60 * 1000;
            const newStart = new Date(range.start.getTime() + diff);
            const newEnd = new Date(range.end.getTime() + diff);
            setInputs(newStart, newEnd);
            loadChart();
        }

        function updateFromInputs() {
            loadChart();
        }

        function changeGraphMode(mode) {
            currentGraphMode = mode;
            loadChart();
        }

        // Initialize with Last 1h
        window.addEventListener('load', () => {
            setRange('1h');
        });

        async function loadChart() {
            const range = getInputs();
            if (!range) return;

            const url = '/api/results/' + targetID + '?start=' + range.start.toISOString() + '&end=' + range.end.toISOString();
            const res = await fetch(url);
            const data = await res.json();

            if (!data) return;

            const ctx = document.getElementById('chart');
            if (chartInstance) {
                chartInstance.destroy();
            }

            const labels = data.map(d => d.Time);
            const chartCtx = ctx.getContext('2d');

            if (currentGraphMode === 'heatmap') {
                // Reuse heatmap logic from dashboard
                const barData = data.map(d => {
                    if (d.ProbeCount === 0) return null;
                    let minVal = d.P1 !== undefined && d.P1 !== 0 ? d.P1 : (d.P0 !== undefined && d.P0 !== 0 ? d.P0 : d.MinNS);
                    let maxVal = d.P99 !== undefined && d.P99 !== 0 ? d.P99 : (d.P100 !== undefined && d.P100 !== 0 ? d.P100 : d.MaxNS);
                    return [minVal / 1000000, maxVal / 1000000];
                });

                const dataset = {
                    label: 'Latency Range',
                    data: barData,
                    backgroundColor: function (context) {
                        const chart = context.chart;
                        const { ctx, chartArea, scales } = chart;
                        if (!chartArea) return null;

                        const index = context.dataIndex;
                        const d = data[index];
                        if (!d || d.ProbeCount === 0) return 'rgba(0,0,0,0)';

                        if (d.Percentiles && d.Percentiles.length === 21) {
                            const pValues = d.Percentiles.map(v => v / 1000000);
                            const p1Val = (d.P1 !== undefined && d.P1 !== 0 ? d.P1 : pValues[0]) / 1000000; // Actually P1 is usually reliable if present
                            // Actually dashboard logic used P1 and P99 for gradient bounds if available
                            // Let's stick to simple dashboard logic
                            // Re-implementing full dashboard logic here is verbose but safe
                            // Simplified for brevity but keeping core gradient logic

                            const topY = scales.y.getPixelForValue((d.P99 || pValues[20]) / 1000000);
                            const bottomY = scales.y.getPixelForValue((d.P1 || pValues[0]) / 1000000);

                            if (Math.abs(topY - bottomY) < 0.1) return 'rgba(0,0,0,1)';

                            const gradient = ctx.createLinearGradient(0, topY, 0, bottomY);

                            // Re-use dashboard approximate logic
                            for (let i = 0; i <= 20; i++) {
                                const val = pValues[i];
                                const y = scales.y.getPixelForValue(val);
                                let stop = (y - topY) / (bottomY - topY);
                                stop = Math.max(0, Math.min(1, stop));
                                const dist = Math.abs(i - 10);
                                const brightness = Math.floor((dist / 10) * 200);
                                gradient.addColorStop(stop, `rgba(${brightness}, ${brightness}, ${brightness}, 1)`);
                            }
                            return gradient;
                        }
                        return 'black';
                    },
                    borderWidth: 0,
                    barPercentage: 1.0,
                    categoryPercentage: 1.0
                };

                // Background plugin for timeouts
                const backgroundPlugin = {
                    id: 'customCanvasBackgroundColor',
                    beforeDraw: (chart) => {
                        const { ctx, chartArea, scales } = chart;
                        ctx.save();
                        data.forEach((d, i) => {
                            const total = d.ProbeCount + d.TimeoutCount;
                            if (total === 0) return;
                            const timeoutPct = d.TimeoutCount / total;

                            const meta = chart.getDatasetMeta(0);
                            const bar = meta.data[i];
                            if (bar) {
                                const width = bar.width;
                                const x = bar.x - width / 2;
                                const gb = Math.floor(255 * (1 - timeoutPct));
                                ctx.fillStyle = `rgb(255, ${gb}, ${gb})`;
                                ctx.fillRect(x, chartArea.top, width, chartArea.bottom - chartArea.top);
                            }
                        });
                        ctx.restore();
                    }
                };

                chartInstance = new Chart(chartCtx, {
                    type: 'bar',
                    data: { labels: labels, datasets: [dataset] },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        scales: {
                            x: { type: 'timeseries', time: { unit: 'minute', displayFormats: { minute: 'HH:mm', hour: 'MM-dd HH:mm' } }, grid: { display: false } },
                            y: { type: 'linear', display: true, title: { display: true, text: 'Latency (ms)' } }
                        },
                        plugins: {
                            zoom: {
                                zoom: {
                                    drag: { enabled: true },
                                    mode: 'x',
                                    onZoomComplete: function ({ chart }) {
                                        const { min, max } = chart.scales.x;
                                        setInputs(new Date(min), new Date(max));
                                        loadChart();
                                    }
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function (context) {
                                        const i = context.dataIndex;
                                        const d = data[i];
                                        if (!d) return '';
                                        return [
                                            `Max: ${(d.P100 / 1e6).toFixed(2)} ms`,
                                            `Median: ${(d.P50 / 1e6).toFixed(2)} ms`,
                                            `Min: ${(d.P0 / 1e6).toFixed(2)} ms`,
                                            `Success: ${d.ProbeCount}`,
                                            `Timeout: ${d.TimeoutCount}`
                                        ];
                                    }
                                }
                            }
                        }
                    },
                    plugins: [backgroundPlugin]
                });

            } else {
                // Line chart mode
                const p0Data = data.map(d => (d.P0 || d.MinNS) / 1000000);
                const p50Data = data.map(d => (d.P50) / 1000000);
                const p100Data = data.map(d => (d.P100 || d.MaxNS) / 1000000);
                const timeoutPercentageData = data.map(d => {
                    const total = d.ProbeCount + d.TimeoutCount;
                    return total > 0 ? (d.TimeoutCount / total) * 100 : 0;
                });

                chartInstance = new Chart(chartCtx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Timeout %',
                                data: timeoutPercentageData,
                                type: 'bar',
                                backgroundColor: 'rgba(255, 99, 132, 0.5)',
                                borderColor: 'rgba(255, 99, 132, 1)',
                                borderWidth: 1,
                                yAxisID: 'y1',
                                barPercentage: 0.5
                            },
                            { label: 'Max (P100)', data: p100Data, borderColor: '#FF0000', backgroundColor: '#FF0000', fill: false, tension: 0.1, borderWidth: 1, yAxisID: 'y' },
                            { label: 'Median (P50)', data: p50Data, borderColor: '#00FF00', backgroundColor: '#00FF00', fill: false, tension: 0.1, borderWidth: 2, yAxisID: 'y' },
                            { label: 'Min (P0)', data: p0Data, borderColor: '#4B0082', backgroundColor: '#4B0082', fill: false, tension: 0.1, borderWidth: 1, yAxisID: 'y' }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        scales: {
                            x: { type: 'timeseries', time: { unit: 'minute', displayFormats: { minute: 'HH:mm', hour: 'MM-dd HH:mm' } } },
                            y: { type: 'linear', display: true, position: 'left', beginAtZero: true },
                            y1: { type: 'linear', display: true, position: 'right', beginAtZero: true, min: 0, max: 100, grid: { drawOnChartArea: false } }
                        },
                        plugins: {
                            zoom: {
                                zoom: {
                                    drag: { enabled: true },
                                    mode: 'x',
                                    onZoomComplete: function ({ chart }) {
                                        const { min, max } = chart.scales.x;
                                        setInputs(new Date(min), new Date(max));
                                        loadChart();
                                    }
                                }
                            }
                        }
                    }
                });
            }
        }
    </script>
</body>

</html>