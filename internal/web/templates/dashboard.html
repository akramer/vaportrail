<!DOCTYPE html>
<html>

<head>
    <title>VaporTrail</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon"></script>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
        }

        .target {
            border: 1px solid #ccc;
            padding: 10px;
            margin-bottom: 20px;
        }

        .chart-container {
            position: relative;
            height: 300px;
            width: 100%;
        }
    </style>
</head>

<body>
    <h1>VaporTrail Dashboard</h1>
    <button onclick="showAddTarget()">Add Target</button>
    <div id="targets">Loading...</div>

    <div id="add-target-modal"
        style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:white; padding:20px; border:1px solid black; z-index:1000;">
        <h2 id="modal-title">Add Target</h2>
        <form id="target-form" onsubmit="submitTarget(event)">
            <input type="hidden" name="id" id="target-id">
            <div>
                <label>Name:</label><br>
                <input type="text" name="name" id="name" required>
            </div>
            <div>
                <label>Address:</label><br>
                <input type="text" name="address" id="address" required>
            </div>
            <div>
                <label>Probe Type:</label><br>
                <select name="type" id="probe-type">
                    <option value="ping">Ping</option>
                    <option value="http">HTTP</option>
                    <option value="dns">DNS</option>
                </select>
            </div>
            <div>
                <label>Probe Interval (s):</label><br>
                <input type="number" name="interval" id="probe-interval" value="1.0" min="0.1" step="0.1">
            </div>
            <div class="form-group">
                <label for="commit-interval">Commit Interval (s):</label>
                <input type="number" id="commit-interval" name="commit_interval" step="1.0" value="60.0">
            </div>
            <div class="form-group">
                <label for="timeout">Timeout (s):</label>
                <input type="number" id="timeout" name="timeout" step="any" value="5.0">
            </div>
            <button type="submit">Save</button>
            <button type="button"
                onclick="document.getElementById('add-target-modal').style.display='none'">Cancel</button>
        </form>
    </div>

    <script>
        let currentTargets = []; // Store targets globally for easy access

        async function submitTarget(e) {
            e.preventDefault();
            const id = document.getElementById('target-id').value;
            const name = document.getElementById('name').value;
            const address = document.getElementById('address').value;
            const probeType = document.getElementById('probe-type').value;
            const probeInterval = parseFloat(document.getElementById('probe-interval').value);
            const commitInterval = parseFloat(document.getElementById('commit-interval').value);
            const timeout = parseFloat(document.getElementById('timeout').value);

            const payload = {
                Name: name,
                Address: address,
                ProbeType: probeType,
                ProbeInterval: probeInterval,
                CommitInterval: commitInterval,
                Timeout: timeout
            };

            let res;
            if (id) {
                res = await fetch('/api/targets/' + id, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
            } else {
                res = await fetch('/api/targets', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
            }

            if (res.ok) {
                document.getElementById('add-target-modal').style.display = 'none';
                loadTargets();
                e.target.reset();
            } else {
                alert("Failed to save target");
            }
        }

        async function loadTargets() {
            const res = await fetch('/api/targets');
            const targets = await res.json();
            if (!targets) targets = [];
            currentTargets = targets; // Update global targets array
            const targetsDiv = document.getElementById('targets');
            targetsDiv.innerHTML = targets.map(t => `
                <div class="target-card">
                    <h3>${t.Name} (${t.ProbeType})</h3>
                    <p>Address: ${t.Address}</p>
                    <p>Interval: ${t.ProbeInterval}s / Commit: ${t.CommitInterval}s / Timeout: ${t.Timeout || 5}s</p>
                    <button onclick="editTarget(${t.ID})">Edit</button>
                    <button style="background-color: #ff4444;" onclick="deleteTarget(${t.ID})">Delete</button>
                    <div class="chart-container">
                        <canvas id="chart-${t.ID}"></canvas>
                    </div>
                </div>
            `).join('');

            for (const t of targets) {
                loadChart(t.ID, 'chart-' + t.ID);
            }
        }

        function editTarget(id) {
            const t = currentTargets.find(t => t.ID === id);
            if (!t) return;

            document.getElementById('modal-title').innerText = 'Edit Target';
            document.getElementById('target-id').value = t.ID;
            document.getElementById('name').value = t.Name;
            document.getElementById('address').value = t.Address;
            document.getElementById('probe-type').value = t.ProbeType;
            document.getElementById('probe-interval').value = t.ProbeInterval;
            document.getElementById('commit-interval').value = t.CommitInterval;
            document.getElementById('timeout').value = t.Timeout || 5.0;

            document.getElementById('add-target-modal').style.display = 'block';
        }

        function showAddTarget() {
            document.getElementById('modal-title').innerText = 'Add Target';
            document.getElementById('target-id').value = '';
            document.getElementById('target-form').reset();
            document.getElementById('commit-interval').value = 60.0;
            document.getElementById('timeout').value = 5.0;
            document.getElementById('add-target-modal').style.display = 'block';
        }

        async function deleteTarget(id) {
            if (!confirm("Are you sure you want to delete this target?")) return;
            const res = await fetch('/api/targets/' + id, { method: 'DELETE' });
            if (res.ok) {
                loadTargets();
            } else {
                alert("Failed to delete target");
            }
        }

        async function loadChart(id, canvasId) {
            const end = new Date();
            const start = new Date(end.getTime() - 60 * 60 * 1000); // Last 1 hour

            const url = '/api/results/' + id + '?start=' + start.toISOString() + '&end=' + end.toISOString();
            const res = await fetch(url);
            const data = await res.json();

            if (!data) return;

            const ctx = document.getElementById(canvasId);
            if (!ctx) return; // Canvas might be gone if target deleted
            const context = ctx.getContext('2d');
            const labels = data.map(d => d.Time);

            // P0, P25, P50, P75, P100 (using result's P fields, converted to ms)
            // Fallback to Min/Max/Avg logic if P-fields are missing (though server should send them as 0 if empty)
            const p0Data = data.map(d => (d.P0 || d.MinNS) / 1000000);
            const p25Data = data.map(d => (d.P25) / 1000000);
            const p50Data = data.map(d => (d.P50) / 1000000);
            const p75Data = data.map(d => (d.P75) / 1000000);
            const p100Data = data.map(d => (d.P100 || d.MaxNS) / 1000000);
            const timeoutPercentageData = data.map(d => {
                const total = d.ProbeCount + d.TimeoutCount;
                return total > 0 ? (d.TimeoutCount / total) * 100 : 0;
            });

            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Timeout %',
                            data: timeoutPercentageData,
                            type: 'bar',
                            backgroundColor: 'rgba(255, 99, 132, 0.5)',
                            borderColor: 'rgba(255, 99, 132, 1)',
                            borderWidth: 1,
                            yAxisID: 'y1',
                            barPercentage: 0.5
                        },
                        { label: 'Max (P100) (ms)', data: p100Data, borderColor: '#FF0000', backgroundColor: '#FF0000', fill: false, tension: 0.1, borderWidth: 1, yAxisID: 'y' },
                        { label: 'Q3 (P75) (ms)', data: p75Data, borderColor: '#FF7F00', backgroundColor: '#FF7F00', fill: false, tension: 0.1, borderWidth: 1, yAxisID: 'y' },
                        { label: 'Median (P50) (ms)', data: p50Data, borderColor: '#00FF00', backgroundColor: '#00FF00', fill: false, tension: 0.1, borderWidth: 2, yAxisID: 'y' },
                        { label: 'Q1 (P25) (ms)', data: p25Data, borderColor: '#0000FF', backgroundColor: '#0000FF', fill: false, tension: 0.1, borderWidth: 1, yAxisID: 'y' },
                        { label: 'Min (P0) (ms)', data: p0Data, borderColor: '#4B0082', backgroundColor: '#4B0082', fill: false, tension: 0.1, borderWidth: 1, yAxisID: 'y' }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    scales: {
                        x: { type: 'time', time: { unit: 'minute' } },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            beginAtZero: true,
                            title: { display: true, text: 'Latency (ms)' }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            beginAtZero: true,
                            grid: {
                                drawOnChartArea: false,
                            },
                            title: { display: true, text: 'Timeouts (%)' },
                            ticks: {
                                callback: function (value) {
                                    return value + "%"
                                }
                            },
                            min: 0,
                            max: 100
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom'
                        }
                    }
                }
            });
        }

        loadTargets();
    </script>
</body>

</html>