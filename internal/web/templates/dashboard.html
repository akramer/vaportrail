{{template "header" .}}

<div style="display: flex; justify-content: space-between; align-items: center;">
    <h1>Dashboard</h1>
</div>
<div style="margin-bottom: 20px; display: flex; align-items: center; gap: 10px;">
    <button onclick="showAddTarget()">Add Target</button>

    <span>Graph Mode: </span>
    <select id="graph-mode" onchange="changeGraphMode(this.value)">
        <option value="heatmap">Heatmap</option>
        <option value="line">Line Chart</option>
    </select>

    <span style="margin-left: 20px;">Start:</span>
    <input type="datetime-local" id="start-time">

    <span>End:</span>
    <input type="datetime-local" id="end-time">

    <button onclick="updateTimeRange()">Update</button>
    <button onclick="resetTimeRange()">Reset (Last 1h)</button>
</div>
<div id="targets">Loading...</div>

<div id="add-target-modal"
    style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:white; padding:20px; border:1px solid black; z-index:1000;">
    <h2 id="modal-title">Add Target</h2>
    <form id="target-form" onsubmit="submitTarget(event)">
        <input type="hidden" name="id" id="target-id">
        <div>
            <label>Name:</label><br>
            <input type="text" name="name" id="name" required>
        </div>
        <div>
            <label>Address:</label><br>
            <input type="text" name="address" id="address" required>
        </div>
        <div>
            <label>Probe Type:</label><br>
            <select name="type" id="probe-type">
                <option value="ping">Ping</option>
                <option value="http">HTTP</option>
                <option value="dns">DNS</option>
            </select>
        </div>
        <div>
            <label>Probe Interval (s):</label><br>
            <input type="number" name="interval" id="probe-interval" value="1.0" min="0.1" step="0.1">
        </div>

        <div class="form-group">
            <label for="timeout">Timeout (s):</label>
            <input type="number" id="timeout" name="timeout" step="any" value="5.0">
        </div>

        <details id="retention-config-section">
            <summary style="cursor: pointer; font-weight: bold; margin-bottom: 10px;">Retention & Rollup Configuration
            </summary>
            <div style="padding: 10px; background: #f9f9f9; border: 1px solid #ddd; border-radius: 4px;">
                <table id="retention-tiers-table" style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr>
                            <th style="text-align: left; padding: 5px;">Window (seconds)</th>
                            <th style="text-align: left; padding: 5px;">Retention</th>
                            <th style="text-align: left; padding: 5px;"></th>
                        </tr>
                    </thead>
                    <tbody id="retention-tiers-body">
                        <!-- Rows will be dynamically populated -->
                    </tbody>
                </table>
                <button type="button" onclick="addRetentionTier()" style="margin-top: 10px;">+ Add Tier</button>
            </div>
        </details>

        <button type="submit">Save</button>
        <button type="button" onclick="document.getElementById('add-target-modal').style.display='none'">Cancel</button>
    </form>
</div>

<script>
    let currentTargets = []; // Store targets globally for easy access
    let currentGraphMode = 'heatmap';

    // Default retention policies for new targets
    const defaultPolicies = [
        { window: 0, retention: 604800 },         // Raw: 7 days
        { window: 60, retention: 15768000 },      // 1m: 6 months
        { window: 300, retention: 31536000 },     // 5m: 1 year
        { window: 3600, retention: 315360000 },   // 1h: 10 years
        { window: 86400, retention: 3153600000 }  // 1d: ~100 years
    ];

    // Format seconds as human-readable string
    function formatSeconds(seconds) {
        if (seconds === 0) return 'Raw';
        if (seconds < 60) return seconds + 's';
        if (seconds < 3600) return (seconds / 60) + 'm';
        if (seconds < 86400) return (seconds / 3600) + 'h';
        return (seconds / 86400) + 'd';
    }

    // Create retention dropdown options
    function createRetentionSelect(currentValue) {
        const presets = [
            { value: 86400, label: '1 day' },
            { value: 259200, label: '3 days' },
            { value: 604800, label: '1 week' },
            { value: 2592000, label: '1 month' },
            { value: 7776000, label: '3 months' },
            { value: 15768000, label: '6 months' },
            { value: 31536000, label: '1 year' },
            { value: 63072000, label: '2 years' },
            { value: 157680000, label: '5 years' },
            { value: 315360000, label: '10 years' },
            { value: 3153600000, label: '100 years' }
        ];

        let html = '<select class="retention-select" onchange="handleRetentionSelectChange(this)">';
        let found = false;
        for (const p of presets) {
            const selected = p.value === currentValue ? ' selected' : '';
            if (p.value === currentValue) found = true;
            html += `<option value="${p.value}"${selected}>${p.label}</option>`;
        }
        html += `<option value="custom"${!found ? ' selected' : ''}>Custom...</option>`;
        html += '</select>';
        html += `<input type="number" class="retention-custom" value="${!found ? currentValue : ''}" style="width: 80px; display: ${!found ? 'inline-block' : 'none'};" placeholder="seconds" min="1">`;
        return html;
    }

    // Create window input (editable for non-raw tiers)
    function createWindowInput(windowValue, isRaw) {
        if (isRaw) {
            return '<span>0 (Raw)</span><input type="hidden" class="window-input" value="0">';
        }
        return `<input type="number" class="window-input" value="${windowValue}" min="1" style="width: 80px;">`;
    }

    // Add a new retention tier row
    function addRetentionTierRow(window, retention) {
        const tbody = document.getElementById('retention-tiers-body');
        const isRaw = window === 0;
        const row = document.createElement('tr');
        row.innerHTML = `
            <td style="padding: 5px;">${createWindowInput(window, isRaw)}</td>
            <td style="padding: 5px;">${createRetentionSelect(retention)}</td>
            <td style="padding: 5px;">
                ${!isRaw ? '<button type="button" onclick="removeRetentionTier(this)" style="background: #ff4444; color: white; border: none; padding: 2px 8px; cursor: pointer;">Ã—</button>' : ''}
            </td>
        `;
        tbody.appendChild(row);
    }

    // Add a new custom tier
    function addRetentionTier() {
        // Default to a new tier with 600s (10m) window and 1 year retention
        addRetentionTierRow(600, 31536000);
    }

    // Remove a tier
    function removeRetentionTier(btn) {
        const row = btn.closest('tr');
        row.remove();
    }

    // Handle retention dropdown change
    function handleRetentionSelectChange(select) {
        const customInput = select.nextElementSibling;
        if (select.value === 'custom') {
            customInput.style.display = 'inline-block';
            customInput.focus();
        } else {
            customInput.style.display = 'none';
        }
    }

    // Build retention policies JSON from form
    function buildRetentionPoliciesJSON() {
        const rows = document.querySelectorAll('#retention-tiers-body tr');
        const policies = [];
        rows.forEach(row => {
            const windowInput = row.querySelector('.window-input');
            const retentionSelect = row.querySelector('.retention-select');
            const retentionCustom = row.querySelector('.retention-custom');

            const windowVal = parseInt(windowInput.value) || 0;
            let retentionVal;
            if (retentionSelect.value === 'custom') {
                retentionVal = parseInt(retentionCustom.value) || 604800;
            } else {
                retentionVal = parseInt(retentionSelect.value);
            }

            policies.push({ window: windowVal, retention: retentionVal });
        });

        // Sort by window size
        policies.sort((a, b) => a.window - b.window);
        return JSON.stringify(policies);
    }

    // Parse retention policies JSON and populate form
    function populateRetentionForm(policiesJSON) {
        const tbody = document.getElementById('retention-tiers-body');
        tbody.innerHTML = '';

        let policies = [];
        try {
            policies = JSON.parse(policiesJSON || '[]');
        } catch (e) {
            policies = [];
        }

        if (policies.length === 0) {
            policies = defaultPolicies;
        }

        // Sort by window
        policies.sort((a, b) => a.window - b.window);

        policies.forEach(p => {
            addRetentionTierRow(p.window, p.retention);
        });
    }

    // Reset retention form to defaults
    function resetRetentionForm() {
        populateRetentionForm(JSON.stringify(defaultPolicies));
    }

    // Initialize time inputs
    function initTimeInputs() {
        const end = new Date();
        const start = new Date(end.getTime() - 60 * 60 * 1000); // Last 1 hour
        setTimeInputs(start, end);
    }

    function setTimeInputs(start, end) {
        // datetime-local expects YYYY-MM-DDTHH:mm
        const toLocalISO = (d) => {
            const offset = d.getTimezoneOffset() * 60000;
            return new Date(d.getTime() - offset).toISOString().slice(0, 16);
        };
        document.getElementById('start-time').value = toLocalISO(start);
        document.getElementById('end-time').value = toLocalISO(end);
    }

    function getTimeRange() {
        const startVal = document.getElementById('start-time').value;
        const endVal = document.getElementById('end-time').value;

        if (startVal && endVal) {
            return { start: new Date(startVal), end: new Date(endVal) };
        }
        return null;
    }

    function updateTimeRange() {
        // Reload all charts with new time range
        for (const t of currentTargets) {
            loadChart(t.ID, 'chart-' + t.ID);
        }
    }

    function resetTimeRange() {
        initTimeInputs();
        updateTimeRange();
    }

    // Initialize on load
    window.addEventListener('load', initTimeInputs);

    function changeGraphMode(mode) {
        currentGraphMode = mode;
        // Reload all charts
        for (const t of currentTargets) {
            const chartInstance = Chart.getChart('chart-' + t.ID);
            if (chartInstance) {
                chartInstance.destroy();
            }
            loadChart(t.ID, 'chart-' + t.ID);
        }
    }

    async function submitTarget(e) {
        e.preventDefault();
        const id = document.getElementById('target-id').value;
        const name = document.getElementById('name').value;
        const address = document.getElementById('address').value;
        const probeType = document.getElementById('probe-type').value;
        const probeInterval = parseFloat(document.getElementById('probe-interval').value);
        const timeout = parseFloat(document.getElementById('timeout').value);

        const payload = {
            Name: name,
            Address: address,
            ProbeType: probeType,
            ProbeInterval: probeInterval,
            Timeout: timeout,
            RetentionPolicies: buildRetentionPoliciesJSON()
        };

        let res;
        if (id) {
            res = await fetch('/api/targets/' + id, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
        } else {
            res = await fetch('/api/targets', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
        }

        if (res.ok) {
            document.getElementById('add-target-modal').style.display = 'none';
            loadTargets();
            e.target.reset();
        } else {
            alert("Failed to save target");
        }
    }

    async function loadTargets() {
        const res = await fetch('/api/targets');
        const targets = await res.json();
        if (!targets) targets = [];
        currentTargets = targets; // Update global targets array
        const targetsDiv = document.getElementById('targets');
        targetsDiv.innerHTML = targets.map(t => `
                <div class="target-card">
                    <h3>${t.Name} (${t.ProbeType})</h3>
                    <p>Address: ${t.Address}</p>
                    <p>Interval: ${t.ProbeInterval}s / Timeout: ${t.Timeout || 5}s</p>
                    <button onclick="window.location.href='/graph/${t.ID}'">View Details</button>
                    <button onclick="editTarget(${t.ID})">Edit</button>
                    <button style="background-color: #ff4444;" onclick="deleteTarget(${t.ID})">Delete</button>
                    <div class="chart-container">
                        <canvas id="chart-${t.ID}"></canvas>
                    </div>
                </div>
            `).join('');

        for (const t of targets) {
            loadChart(t.ID, 'chart-' + t.ID);
        }
    }

    function editTarget(id) {
        const t = currentTargets.find(t => t.ID === id);
        if (!t) return;

        document.getElementById('modal-title').innerText = 'Edit Target';
        document.getElementById('target-id').value = t.ID;
        document.getElementById('name').value = t.Name;
        document.getElementById('address').value = t.Address;
        document.getElementById('probe-type').value = t.ProbeType;
        document.getElementById('probe-interval').value = t.ProbeInterval;
        document.getElementById('timeout').value = t.Timeout || 5.0;
        populateRetentionForm(t.RetentionPolicies);

        document.getElementById('add-target-modal').style.display = 'block';
    }

    function showAddTarget() {
        document.getElementById('modal-title').innerText = 'Add Target';
        document.getElementById('target-id').value = '';
        document.getElementById('target-form').reset();
        document.getElementById('timeout').value = 5.0;
        resetRetentionForm();
        document.getElementById('add-target-modal').style.display = 'block';
    }

    async function deleteTarget(id) {
        if (!confirm("Are you sure you want to delete this target?")) return;
        const res = await fetch('/api/targets/' + id, { method: 'DELETE' });
        if (res.ok) {
            loadTargets();
        } else {
            alert("Failed to delete target");
        }
    }

    async function loadChart(id, canvasId) {
        let start, end;
        const userRange = getTimeRange();

        if (userRange) {
            start = userRange.start;
            end = userRange.end;
        } else {
            end = new Date();
            start = new Date(end.getTime() - 60 * 60 * 1000); // Last 1 hour
        }

        const url = '/api/results/' + id + '?start=' + start.toISOString() + '&end=' + end.toISOString();
        const res = await fetch(url);
        const data = await res.json();

        if (!data) return;

        const canvas = document.getElementById(canvasId);
        if (!canvas) return; // Canvas might be gone if target deleted

        // Check for existing chart instance and destroy it
        const existingChart = Chart.getChart(canvasId);
        if (existingChart) existingChart.destroy();

        VaporTrail.renderLatencyChart({
            canvas: canvas,
            data: data,
            range: { start, end },
            mode: currentGraphMode,
            onZoomComplete: function (start, end) {
                setTimeInputs(start, end);
                updateTimeRange();
            }
        });
    }

    loadTargets();
</script>
{{template "footer" .}}